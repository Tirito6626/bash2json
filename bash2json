#!/bin/bash
#
# bash2json: The most bash-based JSON parser
# Credits: Tirito6626, 2025
# License: Apache License 2.0
#

(return 0 2>/dev/null) && export sourced=true || export sourced=false

function bash2json {
orig_IFS="$IFS"
error() {
  exit=${2}
  echo "error: $1" >&2
  "${exit:=true}" && { ! "${sourced}" && exit 1 || return 1; }
}
  json_trim() {
    local input=$1
    input="${input#"${input%%[![:space:]]*}"}"
    input="${input%"${input##*[![:space:]]}"}" 
 
  inside_string=0
  result=""
  while IFS='' read -r -d '' -n 1 char; do
    [[ "$prevchar" == '\' ]] && result+="$char" && prevchar="$char" && continue
    [[ "$char" == '"' && "$prevchar" != '\' ]] && ((inside_string ^= 1))
    [[ ! "$insidestring" && "$char" == " " ]] && continue || result+="$char"
    prevchar="$char"
  done <<< "$input"
  echo -n "$result"
}
json_append() {
  local input="$(json_trim "$1")"
  local key="$2"
  local value="$3"
  if [[ "$key" =~ \. ]]; then 
    IFS=' ' read key subkey <<< "${key/\./ }"
    local keyout=$(json_query "$input" "$key")
    [[ "$keyout" == null ]] && input=$($FUNCNAME "$input" "$key" '{}') && keyout='{}'
    local newkeyout=$($FUNCNAME "$keyout" "$subkey" "$value")
    [[ "$key" =~ \[[0-9]*\] ]] && local keyout=$(json_query "$input" "${key//\[[0-9]\]/}")
    keyout="${keyout//\[/\\[}"
    newkeyout="${newkeyout//\[/\\[}"
    key="${key//\[[0-9]\]/}"
    input="${input/\"${key}\":${keyout}/\"${key}\":${newkeyout}}"
    echo "${input//\\[/[}"
  elif [[ "$key" =~ "[]" ]]; then 
    case "$value" in 
          true|false|[0-9]|null) : ;;
          *) 
            case "${value:0:1}" in 
              '"'|'{'|'[') : ;;
              *) value='"'"$value"'"' ;; 
            esac
    esac
    key="${key//\[\]/}"
    local keyout=$(json_query "$input" "${key}")
    local newkeyout=$($FUNCNAME "$keyout" "$value")
    keyout="\"${key}\":${keyout//\]/\\]}"
    newkeyout="\"${key}\":${newkeyout//\]\\]}"
    echo "${input/${keyout}/${newkeyout}}"
  else
    #local keyout=$(json_query "$input" "$key")
    if [[ "${input:0:1}" == "{" ]]; then 
      [ -z "$key" ] && error "key missing"
      [ -z "$value" ] && error "value missing"
      case "$value" in 
          true|false|[0-9]|null) : ;;
          *) 
            case "${value:0:1}" in 
              '"'|'{'|'[') : ;;
              *) value='"'"$value"'"' ;; 
            esac
      esac
      if [[ "$key" =~ '=' ]]; then 
        IFS='=' read key type <<< "$key"
        [[ "$type" == "string" && "${value:0:1}" != '"' ]] && value="\"$value\""
      fi
      key="${key//\"}"
      key="${key//\[[0-9]\]/}"

      local keyout=$(json_query "$input" "$key")
      if [[ "$keyout" != "null" ]]; then 
        echo "${input/\"${key}\":${keyout}/\"${key}\":${value}}"
      else 
        [[ "$input" = '{}' ]] && echo "${input/%/\"${key}\":\"$value\"\}}" || echo "${input/%/\"${key}\":$value\}}" 
      fi
    elif [[ "${input:0:1}" == "[" ]]; then
      [ -z "$key" ] && error "key missing"
      if [ ! -z "$value" ]; then
        case "$value" in 
          true|false|[0-9]|null) : ;;
          *) 
            case "${value:0:1}" in 
              '"'|'{'|'[') : ;;
              *) value='"'"$value"'"' ;; 
            esac
        esac
        value='{ "'"$key"'": '"$value"' }'
      else 
        value="$key" 
      fi
      if [[ "$input" == '[]' ]]; then
        echo "[$value]"
      else
      echo "${input/%]/,$value]}"
       # [[ "$input" =~ (.*)\] ]] && echo "${BASH_REMATCH[1]},$value]"
      fi
    else 
      error "can't append JSON: not a valid key type" 
    fi
 fi 
}
array_list() {
local input="$1"
if [[ "${input:0:1}" = '[' ]]; then
  local depth=0
  local result=''
  local prevchar=''
  inside_string=0
    while IFS='' read -r -d '' -n 1 char; do
      [[ "$prevchar" == '\' ]] && result+="$char" && prevchar="$char" && continue
      [[ "$char" == '"' && "$prevchar" != '\' ]] && ((inside_string ^= 1))
      [[ "$char" == "," && (( "$inside_string" = 0 )) ]] && ((depth == 1)) && result+="\n" && continue
      [[ "$char" == "{" ]] && ((++depth))
      [[ "$char" == "}" ]] && ((--depth))
      [[ "$char" == '[' ]] && ((++depth))
      [[ "$char" == "]" ]] && ((--depth))
      ((depth == 0)) && break || result+="$char"
  done < <(printf %s "$input")
  echo -e "${result:1}"
else 
  echo "$input"
fi
}
json_list() {
local input="$1"
if [[ "${input:0:1}" = '{' ]]; then
  local depth=0
  local result=''
  local prevchar=''
  inside_string=0
    while IFS='' read -r -d '' -n 1 char; do
      [[ "$prevchar" == '\' ]] && result+="$char" && prevchar="$char" && continue
      if (( $depth == 1 )); then
        [[ "$char" == '"' && "$prevchar" != '\' ]] && { ((inside_string ^= 1)); continue; }
        [[ "$char" = ":" && $inside_string = 0 ]] && result+=" " && continue
        [[ "$char" == "," && "$inside_string" = 0 ]] && result+="\n" && continue
      fi
      [[ "$char" == "{" ]] && ((++depth))
      [[ "$char" == "}" ]] && ((--depth))
      [[ "$char" == '[' ]] && ((++depth))
      [[ "$char" == "]" ]] && ((--depth))
      ((depth == 0)) && break || result+="$char"
  done < <(printf %s "$input")
  echo -e "${result:1}"
else 
  echo "$input"
fi
}

json_validate() {
  local input="$1"
   trimmed_json=$(json_trim "$input")
  depth=0
  newstring=''
     depth=0
  dquotes=0
  bdepth=0
  type=null
  newstring=''
  firstchar=''
  quoted=true
  prevchar=''
  unquotedchars=''
  while IFS='' read -r -d '' -n 1 char; do
    [[ "$prevchar" == '\' ]] && newstring+="$char" && prevchar="$char" && continue
    [[ "$prevchar" == '{' || "$prevchar" == ':' || "$prevchar" == ',' ]]  && [[ "$char" != '"' && "$char" != 't' && "$char" != 'f' && "$char" != [0-9] && "$char" != '}' && "$char" != '{'  && "$char" != '[' && "$char" != ']' && "$char" != ',' ]] && quoted=false && unquotedchars+="$char" && continue
    if ! "$quoted"; then 
      [[ "$char" != '}' && "$char" != ']' && "$char" != ':' && "$char" != ',' ]] && unquotedchars+="$char" || { unquotedchars+=" "; quoted=true; } 
    fi
    [[ "$prevchar" == ',' && "$char" == ',' ]] && error "unexpected ',,'"
    if [ -z "$firstchar" ]; then 
      firstchar="$char"
      case "$char" in 
        '{') type='object'  ;;
        '[') type='array'   ;;
        '"') type='string'  ;;
        t|f) type='boolean' ;;
        [0-9]) type='int'   ;;
        *)     type=null    ;; 
      esac
      newstring+="$char"
      ((++depth))
      continue 
    fi
    if [[ "$firstchar" == "{" ]]; then 
      newstring+="$char"
      [[ "$char" == '{' ]] && ((++depth))
      [[ "$char" == '}' ]] && ((--depth))
      [[ "$char" == '"' ]] && ((++dquotes))
      [[ "$char" == '[' ]] && ((++bdepth))
      [[ "$char" == ']' ]] && ((--bdepth))
    elif [[ "$firstchar" == "[" ]]; then 
      [[ "$depth" -gt 1 && "$char" == "," ]] && newstring+=" " || newstring+="$char"
      [[ "$char" == '[' ]] && ((++depth))
      [[ "$char" == "]" ]] && ((--depth))
      [[ "$char" == '"' ]] && ((++dquotes))
    elif [[ "$firstchar" == '"' ]]; then
      [[ "$char" == '"' ]] && ((--depth)) || newstring+="$char"
    else 
      newstring+="$char"
      [[ "$char" == ',' ||  "$char" == '}' ]] && newstring=${newstring::-1} && break 
    fi
    prevchar="$char"
  done < <(printf %s "$trimmed_json")
 # set -x
}
json_to_nested_arr() {
while read -r line; do
  read -r name key value subvalue <<< "$line"
   [[ "$subvalue" != " " && "$subvalue" != "" ]] && echo "${name}_${key}[$value]=$subvalue" || echo "$name[$key]=$value"
  done <<< "$1"
}

json_query() {
  local input="$1"
  local key="$2"
  local sub=false
    while read key; do
   if [[ "$key" =~ \. ]]; then 
    sub=true
    read key subkey <<<"${key/\./ }"
    if [ -z "$subkey" ]; then 
      ! "$silent" && error "invalid key invocation: \`$2'; expected <key>.<subkey>"
    fi 
    input=$($FUNCNAME "$input" "$key")
    key="$subkey"
  fi
    if [[ "$key" =~ \[[0-9]*\] ]]; then 
    [[ "${BASH_REMATCH[0]:1:-1}" != "" ]] || error "expected index number"
    keyout=$($FUNCNAME "$input" "${key//\[[0-9]*\]}")
    [[ "${keyout:0:1}" != '[' ]] && error "cannot get index of non-array"
    local arr=($(array_list "$keyout"))
    output="${arr[${BASH_REMATCH[0]:1:-1}]}"
    [ ! -z "$output" ] && echo "$("${raw:=false}" && echo "${output//\"}" || echo "$output")" || echo null
    exit 0
    fi
  trimmed_json=$(json_trim "$input")
  if [ ! -z "$key" ]; then 
  [[ "$trimmed_json"  =~ \"$key\":(.*) ]] && string="${BASH_REMATCH[1]}" || { echo null; exit; }
  depth=0
  type=null
  newstring=''
  firstchar=''
  while IFS='' read -r -d '' -n 1 char; do
    [ -z "$firstchar" ] && firstchar="$char"
    if [[ "$firstchar" == "{" ]]; then 
      newstring+="$char"
      [[ "$char" == "{" ]] && ((++depth))
      [[ "$char" == "}" ]] && ((--depth))
      ((depth == 0)) && break || continue 
    elif [[ "$firstchar" == "[" ]]; then 
      newstring+="$char"
      [[ "$char" == '[' ]] && ((++depth))
      [[ "$char" == "]" ]] && ((--depth))
      ((depth == 0)) && break || continue 
    elif [[ "$firstchar" == '"' ]]; then
      [[ "$char" == '"' ]] && ((--depth)) || newstring+="$char"
      ((depth == 0)) && break || continue 
    else 
      newstring+="$char"
      [[ "$char" == ',' ||  "$char" == '}' ]] && newstring=${newstring::-1} && break 
    fi
  done < <(printf %s "$string")
  if [[ "${firstchar}" == '"' ]]; then 
    "${raw:=false}" && echo -e "${newstring//\"}" || echo -e "${newstring}"
  else 
    echo -e "${newstring}"
  fi
else 
  echo "$trimmed_json"
fi
done <<< "${key//,/\\n}"
}


json_to_arr() {
     while read line; do 
      read key value <<< "$line"
      if [[ ${value:0:1} == "{" ]]; then 
        while read subline; do 
            read subkey subvalue <<< "$subline"
            echo "$output_arr[$key.$subkey]=$subvalue"
        done <<< "$(json_list "$value")"
    
      else 
        echo "$output_arr[$key]=$value"
    fi
    done <<< "$(json_list "$json")"
}
local vers=v2.0.0
local silent=false
local validate=true
declare -a args=()
for arg in "$@"; do
case $arg in
-V|--version)
echo "bash2json [${vers}]"
echo "Copyright (C) 2025 Tirito6626"
exit
;;
-uv)           local ultraverbose=true    ;;
--from-json)   local action=from_json     ;;
--to-json)     local action=to_json       ;;
-q|--query)    local action=query         ;;
-T|--trim)     local action=trim          ;;
-A|--append)   local action=append        ;;
-H|-h|--help)  local action=help          ;;  
-v|--validate) local action=validate      ;;
-N|--no-validate) local validate=false    ;;
-s|--silent)   local silent=true          ;;
--auto-detect) local autodetect=true      ;;
--stdin)       local readfromstdin=true   ;;
-r|--raw)      local raw=true             ;;
--input=*)   local input="${arg#*=}"      ;;
--output=*)  local output_arr="${arg#*=}" ;;
--mode=*)    local mode="${arg#*=}"       ;;
--auto-detect=*) local autodetect="${arg#*=}" ;;
*)              local allargs+=("$arg") ;;
esac
done
"${ultraverbose:=false}" && set -x
if [[ "$action" != "help" && "$action" != "to_json" && "${allargs[0]:0:1}" != '{' && "${allargs[0]:0:1}" != '[' ]]; then
if "${readfromstdin:=false}"; then 
  local var="$(</dev/stdin)"
  local query=${allargs[0]}
  local arg2=${allargs[1]}
  local arg3=${allargs[2]}
else 
  if [ -f "$input" ] || [ -L "$input" ]; then 
    local var="$(<"$input")"
    local query=${allargs[0]}
    local arg2=${allargs[1]}
    local arg3=${allargs[2]}
  elif [[ "${input:0:1}" = '{' ||  "${input:0:1}" = '[' ]]; then 
    local var="$input"
    local query=${allargs[0]}
    local arg2=${allargs[1]}
    local arg3=${allargs[2]}
  else
    local var=${allargs[0]}
    local query=${allargs[1]}
    local arg2=${allargs[2]}
    local arg3=${allargs[3]}
  fi
fi
else 
    local var=${allargs[0]}
    local query=${allargs[1]}
    local arg2=${allargs[2]}
    local arg3=${allargs[3]}
fi
"${validate}" && [[ "${action:=query}" != "validate" && "${action:=query}" != "to_json"  && "${action:=query}" != "help" ]] && json_validate "$var"
[[ "$action" != "help" ]] && [ -z "$var" ] && error "input missing"
case "${action:=query}" in
help)
cat <<-EOF
Usage: $(! "$sourced" && echo "${0}" || echo "$FUNCNAME") <input> <query|key?> <value?> [options?]

Available options:
--from-json <input>                 Convert JSON into associative/indexed array
--to-json   <array>                 Convert associative/indexed array into JSON
-q|--query  <input> <key>           Perform a JSON query (e.g. 'key' or 'key.subkey') (default)
-A|--append <input> <key> <value>   Append key to JSON
-H|-h|--help                        Return this message
-v|--validate <input>               Validate JSON
-N|--no-validate                    Don't validate JSON input before actions
-s|--silent                         Don't return errors
--auto-detect                       Auto-detect key types while using --to-json
--stdin                             Read from standart input
-r|--raw                            Raw output
--input=<file/JSON>                 Set input or file to use as input 
--output=<name>                     Set output array name (doesn't execute it)
--auto-detect=<bool>                Enable/disable auto-detection


--from-json generates single array command with all keys and subkeys
Subkeys are returned as "declare -Ag array=( ... [<key>.<subkey>]=<subkey value> )"

$(! "$sourced" && echo "NOTE: --to-json requires bash2json to be sourced, otherwise bash2json wouldn't be able access it")
EOF
;;
validate)
json_validate "$var"
;;
append)
local key="$query"
local value="$arg2"
json_append "$var" "$key" "$value"
;;
query)
json_query "$var" "$query"
;;
from_json)
  if [ ! -z "$var" ]; then
    evalline=""
    json=$(json_trim  "$var")
    [ -z "$output_arr" ] && output_arr=array_$RANDOM
    evalline+="declare -Ag $output_arr=("
    while read line; do 
      IFS=' ' read key value <<< "$line"
      #echo "key: $key value: $value";
       # eval "$output_arr[$key]=$value"
       evalline+="[$key]=$value "
    done <<< "$(json_list "$json")"
    evalline+=")"
    echo "$evalline"
  fi
;;
trim)
json_trim "$var"
;;
to_json)
local data='{}'
i=0
while IFS=$'\n' read -r var; do
  ((i++))
  ((i > 1)) && data='[]'
  if [[ "$(declare -p "$var" 2>/dev/null)" =~ "declare -A" ]]; then 
  keys=$(eval "echo \${!$var[@]}")
     while read -r key; do
      local value=$(eval "echo -e \${$var[$key]}")
      if [ ! -z "${value}" ] && [[ "$(declare -p "$value" 2>/dev/null)" =~ "declare -A" || "$(declare -p "$value" 2>/dev/null)" =~ "declare -a" ]]
      then 
        local value=$($FUNCNAME "$value" $vars)
      fi
      data=$(json_append "$data" "$key" "$value")
    done <<< "${keys// /$'\n'}"
    data=${data/\],/}
    data=${data/,,/,}
  fi
done <<< "${var/ /$'\n'}"
echo "$data" 
;;
esac
set +x
IFS="$old_IFS"
}
! "$sourced" && bash2json "$@"